---
title: asynchony
tags:
  - 编程
  - TypeScript
---
说 Promise 之前，我们先来回顾一下异步编程的由来。

起初，世界一片混沌，一个奇点爆炸，带来了物质的运动，时间也由此产生。类似的，在计算机的世界中，时间来自于「赋值」，也就是状态的变化：一个变量的先后被赋值就相当于其状态的变化。「赋值」的引入为我们开发程序提供了非常大的便利，但也带来了很大的麻烦：我们在写程序时要时刻留意变量值的变化。而类似于世界本身是由万事万物并发运动的，程序世界中也有很多独立运行的组件，例如一段计算过程、一个进程、一个网络节点等等。这些组件独立运行过程中，各种状态的变化交织，大大增加了整个系统的复杂性，也大大提高了我们设计系统的难度。而克服复杂性是我们程序员一直以来的主题。为了降服这头猛兽，人们先后打磨出一件件工具，下面我们就来回顾一下这段与恶首斗争的历史。
<!-- more -->

## 零、延迟求值
并发过程的复杂度，很大程度上是由于它违背我们人类的认知习惯。我们习惯于线性、单线程、阻塞地进行思考的，而并发世界则是非线性、多线程、非阻塞的运行的。如果我们能想办法控制我们程序的执行顺序，或者说执行时机，将非线性的运行过程转化为线性过程，就能一定程度上克服组件并发计算中，状态变化交织引入的复杂度。那么首先我们就来看一下如何更改一个计算过程的执行时机。

考虑这样一个问题：
TODO: 惰性求值生成无穷序列

## 一、回调函数

拿做早餐来举个例子，我们早上起来，冲杯咖啡、煎个鸡蛋，而冲咖啡之前需要先温一壶开水。如果一个一个按顺序来做，是这样的：

```TypeScript
function boilWater(): void {
    //
}

function makeCoffee(): void {
    //
}

function fryEgg(): void {
    //
}

boilWater()
makeCoffee()
fryEgg()
```

不难想到，这样顺序执行的效率是很低的，因为我们在等温开水的这段时间并没有做任何事，白白浪费了这段时间。
为了省时间，我们自然而然会想到并发的策略：先起一壶水温上，再开火煎鸡蛋，等鸡蛋煎好了，再冲上咖啡，完美的一天就这样开始：

```TypeScript
function boilWater(): void {
    //
}

function makeCoffee(): void {
    //
}

function fryEgg(): void {
    //
}
deferred(boilWater) {
    makeCoffee()
}()
fryEgg()
```

## 二、Promise