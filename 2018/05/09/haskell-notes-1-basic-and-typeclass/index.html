<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.0.0"><link rel="apple-touch-icon" sizes="180x180" href="https://mengqistatic.azureedge.net/staticfiles/avatar/favicon/apple-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://mengqistatic.azureedge.net/staticfiles/avatar/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://mengqistatic.azureedge.net/staticfiles/avatar/favicon/favicon-16x16.png"><link rel="mask-icon" href="https://mengqistatic.azureedge.net/staticfiles/avatar/favicon/favicon-16x16.png" color="#222"><link rel="manifest" href="https://mengqistatic.azureedge.net/staticfiles/avatar/favicon/manifest.json"><meta name="msapplication-config" content="https://mengqistatic.azureedge.net/staticfiles/avatar/favicon/browserconfig.xml"><meta name="google-site-verification" content="4Fw5av3MAK9VoBQQanNGeiDwK9jEJjQBL6jk3PSY-B4"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"mengqi92.github.io",root:"/",scheme:"Mist",version:"7.8.0",exturl:!0,sidebar:{position:"right",display:"hide",offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Haskell 是一门静态类型的纯函数式编程语言，比较著名的就是它的类型系统、「纯函数」性、惰性求值。我个人觉得学习 Haskell 对学习理解其它编程语言（尤其是静态语言）很有帮助，比如 Java 中的泛型、JavaScript 中的 Promise 等等，因此在这里对自己的 Haskell 学习之旅进行一个总结。相信大部分读者和我一样，都是从 C 系语言开始学起的，这里假设你和我一样具有一定的"><meta name="keywords" content="Haskell,学习笔记"><meta property="og:type" content="article"><meta property="og:title" content="Haskell 学习笔记 1：基本语法与类型类"><meta property="og:url" content="http:&#x2F;&#x2F;mengqi92.github.io&#x2F;2018&#x2F;05&#x2F;09&#x2F;haskell-notes-1-basic-and-typeclass&#x2F;index.html"><meta property="og:site_name" content="Mengqi&#39;s blog"><meta property="og:description" content="Haskell 是一门静态类型的纯函数式编程语言，比较著名的就是它的类型系统、「纯函数」性、惰性求值。我个人觉得学习 Haskell 对学习理解其它编程语言（尤其是静态语言）很有帮助，比如 Java 中的泛型、JavaScript 中的 Promise 等等，因此在这里对自己的 Haskell 学习之旅进行一个总结。相信大部分读者和我一样，都是从 C 系语言开始学起的，这里假设你和我一样具有一定的"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https:&#x2F;&#x2F;www.haskell.org&#x2F;img&#x2F;haskell-logo.svg"><meta property="og:updated_time" content="2020-07-19T12:32:08.351Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https:&#x2F;&#x2F;www.haskell.org&#x2F;img&#x2F;haskell-logo.svg"><link rel="canonical" href="http://mengqi92.github.io/2018/05/09/haskell-notes-1-basic-and-typeclass/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Haskell 学习笔记 1：基本语法与类型类 | Mengqi's blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-68396368-1"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-68396368-1")}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?8800f71adfa983d80f6c943ceb1ee330";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Mengqi's blog" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Mengqi's blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">a paranoid android.</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="heartbeat fa-fw"></i>公益 404</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://mengqi92.github.io/2018/05/09/haskell-notes-1-basic-and-typeclass/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://mengqistatic.azureedge.net/staticfiles/avatar/astronaut.png"><meta itemprop="name" content="Mengqi"><meta itemprop="description" content="机器学习、图像处理、统计分析、函数式编程"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Mengqi's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Haskell 学习笔记 1：基本语法与类型类</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-05-09 22:52:14" itemprop="dateCreated datePublished" datetime="2018-05-09T22:52:14+00:00">2018-05-09</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-07-19 12:32:08" itemprop="dateModified" datetime="2020-07-19T12:32:08+00:00">2020-07-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/fp/" itemprop="url" rel="index"><span itemprop="name">函数式编程</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="https://www.haskell.org/img/haskell-logo.svg"></p><p>Haskell 是一门静态类型的纯函数式编程语言，比较著名的就是它的类型系统、「纯函数」性、惰性求值。我个人觉得学习 Haskell 对学习理解其它编程语言（尤其是静态语言）很有帮助，比如 Java 中的泛型、JavaScript 中的 Promise 等等，因此在这里对自己的 Haskell 学习之旅进行一个总结。</p><p>相信大部分读者和我一样，都是从 C 系语言开始学起的，这里假设你和我一样具有一定的 C 系语言的编程基础，因此主要列举一些和 C 系语言不一样的地方。</p><a id="more"></a><h3 id="基本语法">基本语法</h3><h4 id="前缀函数调用">1. 前缀函数调用</h4><p>函数都是以前缀的形式调用的，如：<code>min 2 3</code> 就是取函数 <code>min</code> 施加上两个参数 2 和 3。</p><p>有些函数以前缀形式不方便读，可以改用中缀形式表示，但要用 ``` 符号将函数包起来。</p><h4 id="if">2. if</h4><p>Haskell 中的 <code>if</code>，<code>else</code> 部分不能省略。实际上，这里的 <code>if</code> 是像 <code>[2, 3]</code> 这样的「必然返回结果的表达式」，而非语句。</p><h3 id="列表">列表</h3><h4 id="列表拼接">3. 列表拼接</h4><p>列表拼接使用 <code>:</code> 运算符将元素插入列表头部，如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; '<span class="type">A'</span>:' small cat'</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> small cat</span></pre></td></tr></table></figure><p>而常用的 <code>[]</code> 形式实际上是语法糖：<code>[1,2,3]</code>等同于<code>1:2:3:[]</code>。也就是说，列表不是「构造」出来的，而是通过组合施加 <code>:</code> 得出来的。</p><h4 id="列表的比较">4. 列表的比较</h4><p>只要列表内的元素可以比较，那么这两个列表就能作比较。具体做法是，两个列表各自从前向后挑一个元素出来做比较，如果不相等，则以两个元素的比较结果作为列表的比较结果，否则两个列表继续挑下一个比较，重复这个过程直到最后一个元素。所有元素都相等时，两个列表相等。</p><p>注意，非空列表总比空列表更大。</p><h4 id="range">5. range</h4><p>Haskell 中，列表可以只给出起始元素、第二个元素和上限，让 Haskell 自己推算出来中间元素，比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>,<span class="number">2.</span><span class="number">.10</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span></pre></td></tr></table></figure><p>当步长为 1 时，第二个元素可以省略，上面的式子可以简写为 <code>[1..10]</code>。</p><p>需要注意的是，给出区间的上限并不一定是最后一个元素，比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>,<span class="number">3.</span><span class="number">.10</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span></pre></td></tr></table></figure><p>当 Haskell 推断到元素大于给定的上限时就不会再继续推断，因此上面的列表推断到 9 就截至了。</p><h4 id="无限列表">6. 无限列表</h4><p>作为一个惰性求值的语言，Haskell 支持无限长列表，比如 <code>[13, 26..]</code> 是合法的，在 repl 中执行这个语句会让解释器不停地推断下去。（ 感觉失去控制时可以按 Ctrl-C 刹车:) ）</p><h4 id="列表推导式">7. 列表推导式</h4><p>可以像当初写数学的集合推导式一样声明一个列表，这个特性后来还被 Python 借鉴过去了。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; [x*<span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.5</span>]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&gt; [x*<span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.5</span>], x*<span class="number">2</span> &lt; <span class="number">8</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span></pre></td></tr></table></figure><p>也可以声明两个列表的笛卡尔积：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; [x*y | x &lt;- [<span class="number">1.</span><span class="number">.3</span>], y &lt;- [<span class="number">2.</span><span class="number">.4</span>]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>]</span></pre></td></tr></table></figure><h3 id="类型系统">类型系统</h3><p>Haskell 作为一种静态类型的函数式编程语言，类型系统在 Haskell 中有举足轻重的地位。</p><h4 id="类型声明">类型声明</h4><p>虽然 Haskell 具有类型推断的能力，但我们平时在编写 Haskell 函数时，最好还是显式地在函数声明上方声明它的类型。函数的类型声明就是要声明出这个函数的输入是什么类型、输出是什么类型，例如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="title">removeNonUppercase</span> :: [<span class="type">Char</span>] -&gt; [<span class="type">Char</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="title">removeNonUppercase</span> st = [ c | c &lt;- st, c `elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>] ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="title">addTree</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="title">addTree</span> x y z = x + y + z</span></pre></td></tr></table></figure><p>注意如果函数有多个参数，则参数之间用 <code>-&gt;</code> 分隔（参数和返回值之间同样也使用 <code>-&gt;</code> 分隔，我们后面会介绍为什么这样做）</p><h4 id="类型变量">类型变量</h4><p>类型变量类似 Java 等语言中的泛型，可以将类型声明中的类型泛化，不限制具体的类型，比如系统自带的函数 <code>head</code>：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; :t head</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="title">head</span>: [a] -&gt; a</span></pre></td></tr></table></figure><p><code>head</code> 的类型声明表示了它可以接受装有任何元素类型的列表，并将返回这种元素类型的值（比如传入一个 Int 列表，将返回一个 Int 值）。</p><h4 id="类型类">类型类</h4><p>类型类（typeclass）类似于 Java 中的接口概念，是定义了一组行为的接口。一个类型（type）可以是一个类型类的实例（instance），但必须要实现这个类型类所定义的行为。</p><p>一个类型类的例子是定义相等性的 <code>Eq</code>。一个类型，只要它实现了 <code>Eq</code> 类型类，那么就可以通过 <code>==</code> 运算符判断这个类型不同值的相等性：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; :t (==)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">(==) :: (<span class="type">Eq</span> a) =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span></pre></td></tr></table></figure><p>上面的类型声明中，多了一个 <code>=&gt;</code> 记号，这个叫做<strong>类型约束</strong>，表示后面的类型变量 <code>a</code> 必须满足 <code>Eq a</code> 的约束，就是说 <code>a</code> 的类型必须实现了 <code>Eq</code> 这个类型类。可以类比于 Java 泛型中的 <code>&lt;? implements Eq&gt;</code>。</p><p>为了方便接受，我们刚才都是用 Java 中相似的概念作类比的。然而类型类的概念和 Java 中的接口还是有很大不同的：<strong>Haskell 世界中函数是一等成员，任何 Haskell 函数都可以扩展类型类的行为，类型类在定义时没有声明它的行为</strong>。此外，Java 中接口在定义之时就要在接口内声明好它的行为，之后所有实现接口的类都无一例外地要实现所有行为。而在实际开发中可能用不到接口的所有函数，那些没有用到的函数有时候就通过 <code>return null;</code> 的方式过掉了，这样做其实会给之后的开发埋下隐患。</p><h5 id="常见的几个类型类">常见的几个类型类</h5><h6 id="eq-类型类">Eq 类型类</h6><p><code>Eq</code> 用于判断相等性和不等性，所有 <code>Eq</code> 的实例类型都必须实现 <code>==</code> 和 <code>/=</code> （不等于）两个函数。</p><h6 id="ord-类型类">Ord 类型类</h6><p><code>Ord</code> 用于判断大小，所有 <code>Ord</code> 的实例类型都必须实现 <code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 等函数。</p><h6 id="show-类型类">Show 类型类</h6><p><code>Show</code> 用于表示类型的字符串，<code>show</code> 函数可以取任一 <code>Show</code> 类型类的实例类型作为参数，返回一个表示参数值的字符串。比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; : t show</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="title">show</span> :: (<span class="type">Show</span> a) =&gt; a -&gt; <span class="type">String</span></span></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; show <span class="number">5.334</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">"5.334"</span></span></pre></td></tr></table></figure><h6 id="read-类型类">Read 类型类</h6><p><code>Read</code> 类型类和 <code>Show</code> 正相反，<code>read</code> 函数可以将字符串转换为 <code>Read</code> 的某个实例类型：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; :t read</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="title">read</span> :: (<span class="type">Read</span> a) =&gt; <span class="type">String</span> -&gt; a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&gt; read <span class="string">"8.2"</span> + <span class="number">3.8</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="number">12.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&gt; [read <span class="string">"True"</span> <span class="type">True</span> <span class="type">False</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">[<span class="type">True</span>, <span class="type">True</span>, <span class="type">False</span>]</span></pre></td></tr></table></figure><p>要注意的是，<code>read</code> 函数需要有其它上下文（比如上面例子中的 <code>3.8</code> 和 [True False]）才能推断出要转换到什么类型。只输入 <code>read "4"</code>，haskell repl 会报错。要告诉解释器我们需要转换为什么类型，需要用到类型注解，比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; read <span class="string">"4"</span> :: <span class="type">Int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&gt; read <span class="string">"4"</span> :: <span class="type">Float</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">4.0</span></span></pre></td></tr></table></figure><h6 id="enum-类型类">Enum 类型类</h6><p><code>Enum</code> 类型类的实例都有连续顺序，它的实例类型都需要支持 <code>succ</code> 和 <code>pred</code> 函数获取每个值的后继和前驱，使得我们可以在区间中使用这些类型（这样我们才能写出 <code>[2..10]</code> 这样简练的表达式）。</p><h6 id="bounded-类型类">Bounded 类型类</h6><p><code>Bounded</code> 类型类的实例都有一个上限和下限，分别可通过 <code>maxBound</code> 和 <code>minBound</code> 函数得到。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; :t minBound</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">(<span class="type">Bounded</span> a) =&gt; a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&gt; :t maxBound</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">(<span class="type">Bounded</span> a) =&gt; a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&gt; minBound :: <span class="type">Int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="number">-21474883648</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&gt; maxBound :: <span class="type">Bool</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="type">True</span></span></pre></td></tr></table></figure><p>注意上面 <code>minBound</code> 和 <code>maxBound</code> 的类型声明都是只有一个有类型约束的值，这个值叫做<strong>多态常量（polymorphic constant）</strong>。</p><p>如果元组中项的类型都属于 <code>Bounded</code> 类型类的实例，那么这个元组也属于 <code>Bounded</code> 的实例：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt; maxBound :: (<span class="type">Bool</span>, <span class="type">Int</span>, <span class="type">Chat</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">(<span class="type">True</span>, <span class="number">2147483647</span>, '\<span class="number">1114111</span>')</span></pre></td></tr></table></figure><h6 id="num-类型类">Num 类型类</h6><p><code>Num</code> 类型类用于表示数值。只有已经属于 <code>Show</code> 与 <code>Eq</code> 的实例类型，才可以成为 <code>Num</code> 类型类的实例。</p><h6 id="floating-类型类">Floating 类型类</h6><p><code>Floating</code> 类型类用于存储浮点数，仅包含 <code>Float</code> 和 <code>Double</code> 两种浮点类型。</p><h6 id="integral-类型类">Integral 类型类</h6><p><code>Integral</code> 类型类仅包含整数，实例类型包含 <code>Int</code> 和 <code>Integer</code>（无限版本的 <code>Int</code>）。</p><h2 id="参考资料">参考资料：</h2><ol type="1"><li><span class="exturl" data-url="aHR0cDovL2xlYXJueW91YWhhc2tlbGwuY29tL2NoYXB0ZXJz">Learn you a Haskell for great good!<i class="fa fa-external-link-alt"></i></span></li></ol><h2 id="版权声明">版权声明：</h2><p>本文中所有文字版权均属本人所有，如需转载请注明来源。</p></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Mengqi</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="/http:/mengqi92.github.io/2018/05/09/haskell-notes-1-basic-and-typeclass/" title="Haskell 学习笔记 1：基本语法与类型类">http://mengqi92.github.io/2018/05/09/haskell-notes-1-basic-and-typeclass/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC</span> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Haskell/" rel="tag"># Haskell</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2016/07/01/linear-algebra-6/" rel="prev" title="线性代数拾遗（六）：特征值与特征向量"><i class="fa fa-chevron-left"></i> 线性代数拾遗（六）：特征值与特征向量</a></div><div class="post-nav-item"><a href="/2018/09/18/git-housekeeping/" rel="next" title="Git 仓库大扫除">Git 仓库大扫除 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本语法"><span class="nav-number">1.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#前缀函数调用"><span class="nav-number">1.1.</span> <span class="nav-text">1. 前缀函数调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#if"><span class="nav-number">1.2.</span> <span class="nav-text">2. if</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表"><span class="nav-number">2.</span> <span class="nav-text">列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#列表拼接"><span class="nav-number">2.1.</span> <span class="nav-text">3. 列表拼接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列表的比较"><span class="nav-number">2.2.</span> <span class="nav-text">4. 列表的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#range"><span class="nav-number">2.3.</span> <span class="nav-text">5. range</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无限列表"><span class="nav-number">2.4.</span> <span class="nav-text">6. 无限列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列表推导式"><span class="nav-number">2.5.</span> <span class="nav-text">7. 列表推导式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型系统"><span class="nav-number">3.</span> <span class="nav-text">类型系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类型声明"><span class="nav-number">3.1.</span> <span class="nav-text">类型声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型变量"><span class="nav-number">3.2.</span> <span class="nav-text">类型变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型类"><span class="nav-number">3.3.</span> <span class="nav-text">类型类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常见的几个类型类"><span class="nav-number">3.3.1.</span> <span class="nav-text">常见的几个类型类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#eq-类型类"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">Eq 类型类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ord-类型类"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">Ord 类型类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#show-类型类"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">Show 类型类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#read-类型类"><span class="nav-number">3.3.1.4.</span> <span class="nav-text">Read 类型类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#enum-类型类"><span class="nav-number">3.3.1.5.</span> <span class="nav-text">Enum 类型类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#bounded-类型类"><span class="nav-number">3.3.1.6.</span> <span class="nav-text">Bounded 类型类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#num-类型类"><span class="nav-number">3.3.1.7.</span> <span class="nav-text">Num 类型类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#floating-类型类"><span class="nav-number">3.3.1.8.</span> <span class="nav-text">Floating 类型类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#integral-类型类"><span class="nav-number">3.3.1.9.</span> <span class="nav-text">Integral 类型类</span></a></li></ol></li></ol></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number"></span> <span class="nav-text">参考资料：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#版权声明"><span class="nav-number"></span> <span class="nav-text">版权声明：</span></a></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Mengqi" src="https://mengqistatic.azureedge.net/staticfiles/avatar/astronaut.png"><p class="site-author-name" itemprop="name">Mengqi</p><div class="site-description" itemprop="description">机器学习、图像处理、统计分析、函数式编程</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lbmdxaTky" title="Github → https:&#x2F;&#x2F;github.com&#x2F;mengqi92"><i class="github fa-fw"></i></span> </span><span class="links-of-author-item"><span class="exturl" data-url="bWFpbHRvOm1lbmdxaXBlaUBnbWFpbC5jb20=" title="E-Mail → mailto:mengqipei@gmail.com"><i class="envelope fa-fw"></i></span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9tZW5ncWlwZWk=" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;mengqipei"><i class="twitter fa-fw"></i></span> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="rss fa-fw"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzQuMC8="><img src="/images/cc-by-nc.svg" alt="Creative Commons"></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="link fa-fw"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cDovL3d3dy5mdXppaGFvLm9yZw==" title="http:&#x2F;&#x2F;www.fuzihao.org">切问录</span></li><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cHM6Ly9idXdlbnFpLmdpdGh1Yi5pbw==" title="https:&#x2F;&#x2F;buwenqi.github.io">Wenqi's Blog</span></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="user"></i> </span><span class="author" itemprop="copyrightHolder">Mengqi</span></div><div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly9taXN0LnRoZW1lLW5leHQub3Jn">NexT.Mist</span> 强力驱动</div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script>!function(){var o,n,e=document.getElementsByTagName("link");if(0<e.length)for(i=0;i<e.length;i++)"canonical"==e[i].rel.toLowerCase()&&e[i].href&&(o=e[i].href);n=o?o.split(":")[0]:window.location.protocol.split(":")[0],o||(o=window.location.href),function(){var e=o,i=document.referrer;if(!/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(e)){var t="https"===String(n).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";i?(t+="?r="+encodeURIComponent(document.referrer),e&&(t+="&l="+e)):e&&(t+="?l="+e),(new Image).src=t}}(window)}()</script></body></html>